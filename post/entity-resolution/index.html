<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Source Themes Academic 4.5.0"><meta name=author content="Dainius Jocas"><meta name=description content="Entity Resolution implementation with nothing more than good ol' Opensearch/Elasticsearch"><link rel=alternate hreflang=en-us href=https://www.jocas.lt/blog/post/entity-resolution/><meta name=theme-color content="#2962ff"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/github.min.css crossorigin=anonymous title=hl-light><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/github.min.css crossorigin=anonymous title=hl-dark disabled><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css integrity="sha256-SHMGCYmST46SoyGgo4YR/9AlK1vf3ff84Aq9yK4hdqM=" crossorigin=anonymous><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap"><link rel=stylesheet href=/blog/css/academic.css><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','UA-122337142-2');</script><link rel=manifest href=/blog/index.webmanifest><link rel=icon type=image/png href=/blog/img/icon-32.png><link rel=apple-touch-icon type=image/png href=/blog/img/icon-192.png><link rel=canonical href=https://www.jocas.lt/blog/post/entity-resolution/><meta property="twitter:card" content="summary_large_image"><meta property="og:site_name" content="Dainius Jocas"><meta property="og:url" content="https://www.jocas.lt/blog/post/entity-resolution/"><meta property="og:title" content="Entity Resolution with Opensearch/Elasticsearch | Dainius Jocas"><meta property="og:description" content="Entity Resolution implementation with nothing more than good ol' Opensearch/Elasticsearch"><meta property="og:image" content="https://www.jocas.lt/blog/post/entity-resolution/featured.png"><meta property="twitter:image" content="https://www.jocas.lt/blog/post/entity-resolution/featured.png"><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2022-01-12T00:00:00+00:00"><meta property="article:modified_time" content="2022-01-12T00:00:00+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.jocas.lt/blog/post/entity-resolution/"},"headline":"Entity Resolution with Opensearch/Elasticsearch","image":["https://www.jocas.lt/blog/post/entity-resolution/featured.png"],"datePublished":"2022-01-12T00:00:00Z","dateModified":"2022-01-12T00:00:00Z","author":{"@type":"Person","name":"Dainius Jocas"},"publisher":{"@type":"Organization","name":"Dainius Jocas","logo":{"@type":"ImageObject","url":"https://www.jocas.lt/blog/img/icon-512.png"}},"description":"Entity Resolution implementation with nothing more than good ol' Opensearch/Elasticsearch"}</script><title>Entity Resolution with Opensearch/Elasticsearch | Dainius Jocas</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents><aside class=search-results id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class=col-6><h1>Search</h1></div><div class="col-6 col-search-close"><a class=js-search href=#><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box><input name=q id=search-query placeholder=Search... autocapitalize=off autocomplete=off autocorrect=off spellcheck=false type=search></div></section><section class=section-search-results><div id=search-hits></div></section></div></aside><nav class="navbar navbar-light fixed-top navbar-expand-lg py-0 compensate-for-scrollbar" id=navbar-main><div class=container><a class=navbar-brand href=/blog/>Dainius Jocas</a>
<button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar aria-controls=navbar aria-expanded=false aria-label="Toggle navigation">
<span><i class="fas fa-bars"></i></span></button><div class="collapse navbar-collapse" id=navbar><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/blog/#posts><span>Posts</span></a></li><li class=nav-item><a class=nav-link href=/blog/#projects><span>Projects</span></a></li><li class=nav-item><a class=nav-link href=/blog/#talks><span>Talks</span></a></li><li class=nav-item><a class="nav-link js-search" href=#><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link js-dark-toggle" href=#><i class="fas fa-moon" aria-hidden=true></i></a></li></ul></div></div></nav><article class=article><div class="article-container pt-3"><h1>Entity Resolution with Opensearch/Elasticsearch</h1><div class=article-metadata><div><span><a href=/blog/authors/dainius-jocas/>Dainius Jocas</a></span></div><span class=article-date>Jan 12, 2022</span>
<span class=middot-divider></span><span class=article-reading-time>17 min read</span>
<span class=middot-divider></span><span class=article-categories><i class="fas fa-folder mr-1"></i><a href=/blog/categories/elasticsearch/>elasticsearch</a></span></div><div class="btn-links mb-3"></div></div><div class="article-header article-container featured-image-wrapper mt-4 mb-4" style=max-width:720px;max-height:333px><div style=position:relative><img src=/blog/post/entity-resolution/featured_hu185b9d8a58ff49c36533b3cd24d5342c_96065_720x0_resize_lanczos_2.png alt class=featured-image>
<span class=article-header-caption><a href=https://www.researchgate.net/figure/General-entity-resolution-workflow_fig4_289659973>General entity resolution workflow</a></span></div></div><div class=article-container><div class=article-style><h2 id=tldr>TL;DR</h2><p>The <a href=https://en.wikipedia.org/wiki/Record_linkage>entity resolution</a> can be implemented as a search application and if the requirements are not too crazy then Opensearch/Elasticsearch is good enough.</p><h2 id=introduction>Introduction</h2><p>Say that our company have a curated registry of organizations (only organization names with the number of employees) conveniently indexed in the OpenSearch/Elasticsearch.
Our employer acquired a direct competitor with their own nice little registry (only organization names with their addresses), and we were tasked to integrate the new registry with our old registry, i.e. to perform an entity resolution.
Our task is to iterate through the new registry record by record and try to map them to our &ldquo;Golden registry&rdquo;.
Unfortunately, the only overlapping data is organization names and our matching needs to be based mostly on the organization name.
Let&rsquo;s implement organization name matching by text similarity directly with Opensearch/Elasticsearch.</p><h2 id=requirements>Requirements</h2><p>Say that we were given these organization name similarity rules in the descending order of importance.
Let&rsquo;s have an example query &ldquo;Apple&rdquo; in mind as we go:</p><ol><li>Exact match, e.g. &ldquo;Apple&rdquo;</li><li>Exact first word match, e.g. &ldquo;<strong>Apple</strong> Computers&rdquo;</li><li>Exact not first word match, e.g. &ldquo;Big <strong>Apple</strong> Company&rdquo;</li><li>Partial first word match - start, e.g. &ldquo;<strong>Apple</strong>sauce Company&rdquo;</li><li>Partial first word match - end, e.g. &ldquo;Pine<strong>apple</strong> Manufacturing&rdquo;</li><li>Partial not first word match - end, e.g. &ldquo;Canadian Bake<strong>apple</strong>&rdquo;</li><li>Fuzzy, e.g. &ldquo;<strong>Apply</strong>&rdquo;</li></ol><p>On top of that, we should be able to add other signals that could change the ordering,
e.g. the number of employees: the more employees the matching organization has the higher its matching score.</p><p>&ldquo;Applesauce Company&rdquo; with 100 employees should be lower than &ldquo;Pineapple Manufacturing&rdquo; with 100000 employees despite that
the rule of a <em>partial first word match at the start</em> has a higher name similarity than the <em>partial not first word match at the end</em>.</p><p>And yes, the entity resolution should be implemented only with features provided by Opensearch/Elasticsearch.</p><p>NOTE: the proposed solution is not production ready, use the examples wisely.</p><h3 id=additional-notes-for-development>Additional notes for development</h3><p>To make the development easier we also want:</p><ul><li>to know which rule matched for each hit we can leverage <a href=https://www.elastic.co/guide/en/elasticsearch/reference/6.8/search-request-named-queries-and-filters.html>named queries</a> feature (or try the highlighting<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>),</li><li>give each rule a normalized score (<a href=https://en.wikipedia.org/wiki/Tf%E2%80%93idf>TF-IDF</a> is hard to normalize),</li><li>matching of strings should be case-insensitive,</li><li>Index (conveniently names <code>organizations</code>) contains the sample organizations list (extracted from the requirements examples),</li><li>Work out the examples in Kibana/Dashboards,</li></ul><p>The indexing of organizations can be done with this simple command:</p><pre><code class=language-text>PUT organizations/_bulk
{ &quot;index&quot; : { &quot;_id&quot; : &quot;1&quot; } }
{ &quot;name&quot; : &quot;Apple&quot; }
{ &quot;index&quot; : { &quot;_id&quot; : &quot;2&quot; } }
{ &quot;name&quot; : &quot;Apple Computers&quot; }
{ &quot;index&quot; : { &quot;_id&quot; : &quot;3&quot; } }
{ &quot;name&quot; : &quot;Big Apple Company&quot; }
{ &quot;index&quot; : { &quot;_id&quot; : &quot;4&quot; } }
{ &quot;name&quot; : &quot;Applesauce Company&quot; }
{ &quot;index&quot; : { &quot;_id&quot; : &quot;5&quot; } }
{ &quot;name&quot; : &quot;Pineapple Manufacturing&quot; }
{ &quot;index&quot; : { &quot;_id&quot; : &quot;6&quot; } }
{ &quot;name&quot; : &quot;Canadian Bakeapple&quot; }
{ &quot;index&quot; : { &quot;_id&quot; : &quot;7&quot; } }
{ &quot;name&quot; : &quot;Apply&quot; }
</code></pre><h2 id=implementation-strategy>Implementation Strategy</h2><p>Let&rsquo;s split the implementation into 3 parts:</p><ul><li>implement the organization name matching requirements,</li><li>implement the scoring signal based on the number of employees,</li><li>fine-tune the scoring function.</li></ul><h2 id=string-matching-implementation>String Matching Implementation</h2><p>In the following sections we&rsquo;ll implement all string matching signals with the OpenSearch/Elasticsearch text analysis features.
I&rsquo;ll work out each requirement in isolation.
For each rule we will define a subfield of the <code>name</code> attribute with an analyzer and a corresponding query clause.</p><h3 id=exact-match>Exact match</h3><p>Exact matching is rather simple to implement, just use <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/keyword.html#keyword-field-type><code>keyword</code></a> datatype with a <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/normalizer.html>normalizer</a> that <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lowercase-tokenfilter.html>lowercases</a> the string.</p><p>Index configuration:</p><pre><code class=language-kibana>PUT organizations
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;normalizer&quot;: {
        &quot;lowercased_keyword&quot;: {
          &quot;type&quot;: &quot;custom&quot;,
          &quot;filter&quot;: [
            &quot;lowercase&quot;
          ]
        }
      }
    }
  },
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;name&quot;: {
        &quot;type&quot;: &quot;keyword&quot;, 
        &quot;fields&quot;: {
          &quot;keyword_lowercased&quot;: {
            &quot;type&quot;: &quot;keyword&quot;,
            &quot;normalizer&quot;: &quot;lowercased_keyword&quot;
          }
        }
      }
    }
  }
}
</code></pre><p>Query:</p><pre><code class=language-kibana>GET organizations/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;term&quot;: {
          &quot;name.keyword_lowercased&quot;: {
            &quot;value&quot;: &quot;Apple&quot;,
            &quot;_name&quot;: &quot;exact_match&quot;
          }
        }
      },
      &quot;boost&quot;: 7
    }
  }
}
</code></pre><p>Matches exactly one organization:</p><pre><code class=language-json>{
  &quot;took&quot; : 3,
  &quot;timed_out&quot; : false,
  &quot;_shards&quot; : {
    &quot;total&quot; : 1,
    &quot;successful&quot; : 1,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  },
  &quot;hits&quot; : {
    &quot;total&quot; : {
      &quot;value&quot; : 1,
      &quot;relation&quot; : &quot;eq&quot;
    },
    &quot;max_score&quot; : 7.0,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;1&quot;,
        &quot;_score&quot; : 7.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Apple&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;exact_match&quot;
        ]
      }
    ]
  }
}
</code></pre><h3 id=exact-first-word-match>Exact first word match</h3><p>With this requirement we want the query to match the first word of the organization name<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>We can implement the requirement by simply indexing only the first token.
To achieve it we could use the <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-limit-token-count-tokenfilter.html><code>limit</code></a> token filter.</p><p>Index configuration:</p><pre><code class=language-text>PUT organizations
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;analyzer&quot;: {
        &quot;standard_one_token_limit&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;limit&quot;
          ]
        }
      }
    }
  },
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;name&quot;: {
        &quot;type&quot;: &quot;keyword&quot;, 
        &quot;fields&quot;: {
          &quot;first_token&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot;: &quot;standard_one_token_limit&quot;
          }
        }
      }
    }
  }
}
</code></pre><p>We leverage the fact that by default the <code>limit</code> token filter defaults <code>max_token_count</code> parameters to 1 token.
And we don&rsquo;t need to define a new token filter (key damage to the keyboard, yay).</p><p>Query:</p><pre><code class=language-text>GET organizations/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;term&quot;: {
          &quot;name.first_token&quot;: {
            &quot;value&quot;: &quot;Apple&quot;,
            &quot;_name&quot;: &quot;Exact first word match&quot;
          }
        }
      },
      &quot;boost&quot;: 6
    }
  }
}
</code></pre><p>Hits:</p><pre><code class=language-json>{
  &quot;took&quot; : 1,
  &quot;timed_out&quot; : false,
  &quot;_shards&quot; : {
    &quot;total&quot; : 1,
    &quot;successful&quot; : 1,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  },
  &quot;hits&quot; : {
    &quot;total&quot; : {
      &quot;value&quot; : 2,
      &quot;relation&quot; : &quot;eq&quot;
    },
    &quot;max_score&quot; : 6.0,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;1&quot;,
        &quot;_score&quot; : 6.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Apple&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Exact first word match&quot;
        ]
      },
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;2&quot;,
        &quot;_score&quot; : 6.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Apple Computers&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Exact first word match&quot;
        ]
      }
    ]
  }
}
</code></pre><p>Note that not only &ldquo;Apple Computers&rdquo; matched but also &ldquo;Apple&rdquo; matched.
This makes sense because &ldquo;Apple&rdquo; has only one word it is <em>the first word</em>.</p><p>If we wanted to exclude the &ldquo;Apple&rdquo; match we could combine the <code>Exact first word match</code> with the <code>Exact match</code> and construct a bool query, e.g.:</p><pre><code class=language-text>GET organizations/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;bool&quot;: {
          &quot;_name&quot;: &quot;Exact first word match&quot;,
          &quot;must&quot;: [
            {
              &quot;term&quot;: {
                &quot;name.first_token&quot;: {
                  &quot;value&quot;: &quot;Apple&quot;
                }
              }
            }
          ],
          &quot;must_not&quot;: [
            {
              &quot;term&quot;: {
                &quot;name&quot;: {
                  &quot;value&quot;: &quot;Apple&quot;
                }
              }
            }
          ]
        }
      },
      &quot;boost&quot;: 6
    }
  }
}
</code></pre><p>For similar situations we could act similarly but let&rsquo;s keep it simple.</p><h3 id=exact-not-first-word-match>Exact not first word match</h3><p>E.g.: query &ldquo;Apple&rdquo; should match &ldquo;Big Apple Company&rdquo;.
The interesting bit is how to differentiate this rule from the <code>Exact first word match</code>?
As an implementation we could create a boolean query that filters out the first word match.
Another way to implement the is not to index the first word of the organization name.
A slight complication with this approach is that the query time analyzer should be different from
the index time analyzer to prevent the removal of the first (and probably the only) word from the query.
Let&rsquo;s proceed with the second approach because I think it is more interesting.</p><pre><code class=language-text>PUT organizations
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;analyzer&quot;: {
        &quot;tokenized&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;lowercase&quot;
          ]
        },
        &quot;tokenized_without_first_word&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;remove_first_word&quot;,
            &quot;lowercase&quot;
          ]
        }
      },
      &quot;filter&quot;: {
        &quot;remove_first_word&quot;: {
          &quot;type&quot;: &quot;predicate_token_filter&quot;,
          &quot;script&quot;: {
            &quot;source&quot;: &quot;token.position != 0&quot;
          }
        }
      }
    }
  },
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;name&quot;: {
        &quot;type&quot;: &quot;keyword&quot;, 
        &quot;fields&quot;: {
          &quot;tokenized_without_first_word&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot;: &quot;tokenized_without_first_word&quot;,
            &quot;search_analyzer&quot;: &quot;tokenized&quot;
          }
        }
      }
    }
  }
}
</code></pre><p>Note, for the sake of simplicity for examples we assume only one word queries.</p><p>Query:</p><pre><code class=language-text>GET organizations/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;match&quot;: {
          &quot;name.tokenized_without_first_word&quot;: {
            &quot;query&quot;: &quot;Apple&quot;,
            &quot;_name&quot;: &quot;Exact not first word match&quot;
          }
        }
      },
      &quot;boost&quot;: 5
    }
  }
}
</code></pre><p>Hits</p><pre><code class=language-json>{
  &quot;took&quot; : 1,
  &quot;timed_out&quot; : false,
  &quot;_shards&quot; : {
    &quot;total&quot; : 1,
    &quot;successful&quot; : 1,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  },
  &quot;hits&quot; : {
    &quot;total&quot; : {
      &quot;value&quot; : 1,
      &quot;relation&quot; : &quot;eq&quot;
    },
    &quot;max_score&quot; : 6.0,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;3&quot;,
        &quot;_score&quot; : 6.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Big Apple Company&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Exact not first word match&quot;
        ]
      }
    ]
  }
}
</code></pre><h3 id=partial-first-word-match---start>Partial first word match - start</h3><p>E.g. Query &ldquo;Apple&rdquo; should match &ldquo;Applesauce Company&rdquo;.
Probably we could get away with a simple prefix query, but if we want to make it fast for larger indices we should do <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenfilter.html>edge n-grams token filter</a>.
The idea is to keep only this first word and then apply the edge n-gram token filter on it.
Of course, query analyzer should be specified without edge n-gram token filter to prevent false hits from matching a couple of first characters from the query, e.g. query &ldquo;Apps&rdquo; would match &ldquo;Apple&rdquo; which we don&rsquo;t want.</p><p>Index configuration:</p><pre><code class=language-text>PUT organizations
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;analyzer&quot;: {
        &quot;standard_first_token_limit&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;limit&quot;,
            &quot;lowercase&quot;
          ]
        },
        &quot;standard_first_token_limit_edge_ngrams&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;limit&quot;,
            &quot;1_10_edgegrams&quot;,
            &quot;lowercase&quot;
          ]
        }
      },
      &quot;filter&quot;: {
        &quot;1_10_edgegrams&quot;: {
          &quot;type&quot;: &quot;edge_ngram&quot;,
          &quot;min_gram&quot;: 1,
          &quot;max_gram&quot;: 10
        }
      }
    }
  },
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;name&quot;: {
        &quot;type&quot;: &quot;keyword&quot;, 
        &quot;fields&quot;: {
          &quot;first_token_edge_ngram&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot;: &quot;standard_first_token_limit_edge_ngrams&quot;,
            &quot;search_analyzer&quot;: &quot;standard_first_token_limit&quot;
          }
        }
      }
    }
  }
}
</code></pre><p>Here the <code>max_ngram</code> is set to 10 for no big reason, it really depends on your data.</p><p>Query:</p><pre><code class=language-text>GET organizations/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;match&quot;: {
          &quot;name.first_token_edge_ngram&quot;: {
            &quot;query&quot;: &quot;Apple&quot;,
            &quot;_name&quot;: &quot;Partial first word match - start&quot;
          }
        }
      },
      &quot;boost&quot;: 4
    }
  }
}
</code></pre><p>Hits:</p><pre><code class=language-json>{
  &quot;took&quot; : 1,
  &quot;timed_out&quot; : false,
  &quot;_shards&quot; : {
    &quot;total&quot; : 1,
    &quot;successful&quot; : 1,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  },
  &quot;hits&quot; : {
    &quot;total&quot; : {
      &quot;value&quot; : 3,
      &quot;relation&quot; : &quot;eq&quot;
    },
    &quot;max_score&quot; : 4.0,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;1&quot;,
        &quot;_score&quot; : 4.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Apple&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Partial first word match - start&quot;
        ]
      },
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;2&quot;,
        &quot;_score&quot; : 4.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Apple Computers&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Partial first word match - start&quot;
        ]
      },
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;4&quot;,
        &quot;_score&quot; : 4.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Applesauce Company&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Partial first word match - start&quot;
        ]
      }
    ]
  }
}
</code></pre><p>Note that &ldquo;Apple&rdquo; and &ldquo;Apple Computers&rdquo; also matched along the &ldquo;Applesauce Company&rdquo;.
We could prevent matching the first two by doing the bool query with must_not match on the whole first token.</p><h3 id=partial-first-word-match---end>Partial first word match - end</h3><p>E.g. Query &ldquo;Apple&rdquo; should match &ldquo;Pineapple Manufacturing&rdquo;.
In other words, the query string should be the ending of the first word of the organization name.
The idea is to take the first word, reverse it, apply edge n-grams, reverse those n-grams.
The search time analyzer should not have an edge n-grams token filter.</p><p>Index configuration:</p><pre><code class=language-text>PUT organizations
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;analyzer&quot;: {
        &quot;standard_first_token_limit&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;limit&quot;,
            &quot;lowercase&quot;
          ]
        },
        &quot;standard_one_token_limit_endings&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;limit&quot;,
            &quot;lowercase&quot;,
            &quot;reverse&quot;,
            &quot;1_10_edgegrams&quot;,
            &quot;reverse&quot;
          ]
        }
      },
      &quot;filter&quot;: {
        &quot;1_10_edgegrams&quot;: {
          &quot;type&quot;: &quot;edge_ngram&quot;,
          &quot;min_gram&quot;: 1,
          &quot;max_gram&quot;: 10
        }
      }
    }
  },
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;name&quot;: {
        &quot;type&quot;: &quot;keyword&quot;, 
        &quot;fields&quot;: {
          &quot;first_word_end_ngrams&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot;: &quot;standard_one_token_limit_endings&quot;,
            &quot;search_analyzer&quot;: &quot;standard_first_token_limit&quot;
          }
        }
      }
    }
  }
}
</code></pre><p>Query:</p><pre><code class=language-text>GET organizations/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;match&quot;: {
          &quot;name.first_word_end_ngrams&quot;: {
            &quot;query&quot;: &quot;Apple&quot;,
            &quot;_name&quot;: &quot;Partial first word match - end&quot;
          }
        }
      },
      &quot;boost&quot;: 3
    }
  }
}
</code></pre><p>Hits:</p><pre><code class=language-text>{
  &quot;took&quot; : 1,
  &quot;timed_out&quot; : false,
  &quot;_shards&quot; : {
    &quot;total&quot; : 1,
    &quot;successful&quot; : 1,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  },
  &quot;hits&quot; : {
    &quot;total&quot; : {
      &quot;value&quot; : 3,
      &quot;relation&quot; : &quot;eq&quot;
    },
    &quot;max_score&quot; : 3.0,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;1&quot;,
        &quot;_score&quot; : 3.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Apple&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Partial first word match - end&quot;
        ]
      },
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;2&quot;,
        &quot;_score&quot; : 3.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Apple Computers&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Partial first word match - end&quot;
        ]
      },
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;5&quot;,
        &quot;_score&quot; : 3.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Pineapple Manufacturing&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Partial first word match - end&quot;
        ]
      }
    ]
  }
}
</code></pre><h3 id=partial-not-first-word-match---end>Partial not first word match - end</h3><p>E.g. query &ldquo;Apple&rdquo; should match &ldquo;Canadian Bakeapple&rdquo;.
The idea is to tokenize, lowercase, remove first word, reverse tokens, create edge n-grams, reverse back.
Search time analyzer should not include edge n-grams.</p><p>Index configuration:</p><pre><code class=language-text>PUT organizations
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;analyzer&quot;: {
        &quot;standard_first_token_limit&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;limit&quot;,
            &quot;lowercase&quot;
          ]
        },
        &quot;standard_remaining_token_endings&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;remove_first_word&quot;,
            &quot;lowercase&quot;,
            &quot;reverse&quot;,
            &quot;1_10_edgegrams&quot;,
            &quot;reverse&quot;
          ]
        }
      },
      &quot;filter&quot;: {
        &quot;1_10_edgegrams&quot;: {
          &quot;type&quot;: &quot;edge_ngram&quot;,
          &quot;min_gram&quot;: 1,
          &quot;max_gram&quot;: 10
        },
        &quot;remove_first_word&quot;: {
          &quot;type&quot;: &quot;predicate_token_filter&quot;,
          &quot;script&quot;: {
            &quot;source&quot;: &quot;token.position != 0&quot;
          }
        }
      }
    }
  },
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;name&quot;: {
        &quot;type&quot;: &quot;keyword&quot;, 
        &quot;fields&quot;: {
          &quot;remaining_words_end_ngrams&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot;: &quot;standard_remaining_token_endings&quot;,
            &quot;search_analyzer&quot;: &quot;standard_first_token_limit&quot;
          }
        }
      }
    }
  }
}
</code></pre><p>Query:</p><pre><code class=language-text>GET organizations/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;match&quot;: {
          &quot;name.remaining_words_end_ngrams&quot;: {
            &quot;query&quot;: &quot;Apple&quot;,
            &quot;_name&quot;: &quot;Partial not first word match - end&quot;
          }
        }
      },
      &quot;boost&quot;: 2
    }
  }
}
</code></pre><p>Hits:</p><pre><code class=language-json>{
  &quot;took&quot; : 1,
  &quot;timed_out&quot; : false,
  &quot;_shards&quot; : {
    &quot;total&quot; : 1,
    &quot;successful&quot; : 1,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  },
  &quot;hits&quot; : {
    &quot;total&quot; : {
      &quot;value&quot; : 2,
      &quot;relation&quot; : &quot;eq&quot;
    },
    &quot;max_score&quot; : 2.0,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;3&quot;,
        &quot;_score&quot; : 2.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Big Apple Company&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Partial not first word match - end&quot;
        ]
      },
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;6&quot;,
        &quot;_score&quot; : 2.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Canadian Bakeapple&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Partial not first word match - end&quot;
        ]
      }
    ]
  }
}
</code></pre><h3 id=fuzzy>Fuzzy</h3><p>E.g. query &ldquo;Apple&rdquo; should match &ldquo;Apply&rdquo;.
It is pretty much the exact match but with some <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html#query-dsl-match-query-fuzziness>fuzziness</a> allowed.</p><p>Index configuration:</p><pre><code class=language-text>PUT organizations
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;normalizer&quot;: {
        &quot;lowercased_keyword&quot;: {
          &quot;type&quot;: &quot;custom&quot;,
          &quot;filter&quot;: [
            &quot;lowercase&quot;
          ]
        }
      }
    }
  },
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;name&quot;: {
        &quot;type&quot;: &quot;keyword&quot;, 
        &quot;fields&quot;: {
          &quot;keyword_lowercased&quot;: {
            &quot;type&quot;: &quot;keyword&quot;,
            &quot;normalizer&quot;: &quot;lowercased_keyword&quot;
          }
        }
      }
    }
  }
}
</code></pre><p>Query:</p><pre><code class=language-text>GET organizations/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;match&quot;: {
          &quot;name&quot;: {
            &quot;query&quot;: &quot;Apple&quot;,
            &quot;fuzziness&quot;: 1,
            &quot;_name&quot;: &quot;fuzzy_1&quot;
          }
        }
      },
      &quot;boost&quot;: 1
    }
  }
}
</code></pre><p>Hits:</p><pre><code class=language-json>{
  &quot;took&quot; : 1,
  &quot;timed_out&quot; : false,
  &quot;_shards&quot; : {
    &quot;total&quot; : 1,
    &quot;successful&quot; : 1,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  },
  &quot;hits&quot; : {
    &quot;total&quot; : {
      &quot;value&quot; : 2,
      &quot;relation&quot; : &quot;eq&quot;
    },
    &quot;max_score&quot; : 1.0,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;1&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Apple&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;fuzzy_1&quot;
        ]
      },
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;7&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Apply&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;fuzzy_1&quot;
        ]
      }
    ]
  }
}
</code></pre><p>In some circumstances we might allow fuzziness set to more than 1.</p><h2 id=lets-combine-the-pieces-together>Let&rsquo;s combine the pieces together</h2><p>Phew, that was pretty involved.
Let&rsquo;s combine the previous examples into one, so our requirements are satisfied.</p><p>Index configuration is constructed by merging analysis components and adding fields from all the examples:</p><pre><code class=language-text>PUT organizations
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;normalizer&quot;: {
        &quot;lowercased_keyword&quot;: {
          &quot;type&quot;: &quot;custom&quot;,
          &quot;filter&quot;: [
            &quot;lowercase&quot;
          ]
        }
      },
      &quot;filter&quot;: {
        &quot;1_10_edgegrams&quot;: {
          &quot;type&quot;: &quot;edge_ngram&quot;,
          &quot;min_gram&quot;: 1,
          &quot;max_gram&quot;: 10
        },
        &quot;remove_first_word&quot;: {
          &quot;type&quot;: &quot;predicate_token_filter&quot;,
          &quot;script&quot;: {
            &quot;source&quot;: &quot;token.position != 0&quot;
          }
        }
      },
      &quot;analyzer&quot;: {
        &quot;standard_one_token_limit&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;limit&quot;,
            &quot;lowercase&quot;
          ]
        },
        &quot;tokenized&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;lowercase&quot;
          ]
        },
        &quot;tokenized_without_first_word&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;remove_first_word&quot;,
            &quot;lowercase&quot;
          ]
        },
        &quot;standard_first_token_limit_edge_ngrams&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;limit&quot;,
            &quot;lowercase&quot;,
            &quot;1_10_edgegrams&quot;
          ]
        },
        &quot;standard_first_token_limit&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;limit&quot;,
            &quot;lowercase&quot;
          ]
        },
        &quot;standard_remaining_token_endings&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;remove_first_word&quot;,
            &quot;lowercase&quot;,
            &quot;reverse&quot;,
            &quot;1_10_edgegrams&quot;,
            &quot;reverse&quot;
          ]
        },
        &quot;standard_one_token_limit_endings&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;limit&quot;,
            &quot;lowercase&quot;,
            &quot;reverse&quot;,
            &quot;1_10_edgegrams&quot;,
            &quot;reverse&quot;
          ]
        }
      }
    }
  },
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;name&quot;: {
        &quot;type&quot;: &quot;keyword&quot;, 
        &quot;fields&quot;: {
          &quot;first_token&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot;: &quot;standard_one_token_limit&quot;
          },
          &quot;tokenized_without_first_word&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot;: &quot;tokenized_without_first_word&quot;,
            &quot;search_analyzer&quot;: &quot;tokenized&quot;
          },
          &quot;first_token_edge_ngram&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot;: &quot;standard_first_token_limit_edge_ngrams&quot;,
            &quot;search_analyzer&quot;: &quot;standard_first_token_limit&quot;
          },
          &quot;first_word_end_ngrams&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot;: &quot;standard_one_token_limit_endings&quot;,
            &quot;search_analyzer&quot;: &quot;standard_first_token_limit&quot;
          },
          &quot;remaining_words_end_ngrams&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot;: &quot;standard_remaining_token_endings&quot;,
            &quot;search_analyzer&quot;: &quot;standard_first_token_limit&quot;
          },
          &quot;keyword_lowercased&quot;: {
            &quot;type&quot;: &quot;keyword&quot;,
            &quot;normalizer&quot;: &quot;lowercased_keyword&quot;
          }
        }
      }
    }
  }
}
</code></pre><p>Here</p><p>The query is constructed from all the previous examples simply by adding constant score queries to the <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-dis-max-query.html>dis_max</a> query:</p><pre><code class=language-text>GET organizations/_search
{
  &quot;query&quot;: {
    &quot;dis_max&quot;: {
      &quot;queries&quot;: [
        {
          &quot;constant_score&quot;: {
            &quot;filter&quot;: {
              &quot;term&quot;: {
                &quot;name.keyword_lowercased&quot;: {
                  &quot;value&quot;: &quot;Apple&quot;,
                  &quot;_name&quot;: &quot;exact_match&quot;
                }
              }
            },
            &quot;boost&quot;: 7
          }
        },
        {
          &quot;constant_score&quot;: {
            &quot;filter&quot;: {
              &quot;match&quot;: {
                &quot;name.first_token&quot;: {
                  &quot;query&quot;: &quot;Apple&quot;,
                  &quot;_name&quot;: &quot;Exact first word match&quot;
                }
              }
            },
            &quot;boost&quot;: 6
          }
        },
        {
          &quot;constant_score&quot;: {
            &quot;filter&quot;: {
              &quot;match&quot;: {
                &quot;name.tokenized_without_first_word&quot;: {
                  &quot;query&quot;: &quot;Apple&quot;,
                  &quot;_name&quot;: &quot;Exact not first word match&quot;
                }
              }
            },
            &quot;boost&quot;: 5
          }
        },
        {
          &quot;constant_score&quot;: {
            &quot;filter&quot;: {
              &quot;match&quot;: {
                &quot;name.first_token_edge_ngram&quot;: {
                  &quot;query&quot;: &quot;Apple&quot;,
                  &quot;_name&quot;: &quot;Partial first word match - start&quot;
                }
              }
            },
            &quot;boost&quot;: 4
          }
        },
        {
          &quot;constant_score&quot;: {
            &quot;filter&quot;: {
              &quot;match&quot;: {
                &quot;name.first_word_end_ngrams&quot;: {
                  &quot;query&quot;: &quot;Apple&quot;,
                  &quot;_name&quot;: &quot;Partial first word match - end&quot;
                }
              }
            },
            &quot;boost&quot;: 3
          }
        },
        {
          &quot;constant_score&quot;: {
            &quot;filter&quot;: {
              &quot;match&quot;: {
                &quot;name.remaining_words_end_ngrams&quot;: {
                  &quot;query&quot;: &quot;Apple&quot;,
                  &quot;_name&quot;: &quot;Partial not first word match - end&quot;
                }
              }
            },
            &quot;boost&quot;: 2
          }
        },
        {
          &quot;constant_score&quot;: {
            &quot;filter&quot;: {
              &quot;match&quot;: {
                &quot;name&quot;: {
                  &quot;query&quot;: &quot;Apple&quot;,
                  &quot;fuzziness&quot;: 1,
                  &quot;_name&quot;: &quot;fuzzy_1&quot;
                }
              }
            },
            &quot;boost&quot;: 1
          }
        }
      ]
    }
  }
}
</code></pre><p>Finally, the list of organizations ranked by the name similarity:</p><pre><code class=language-json>{
  &quot;took&quot; : 2,
  &quot;timed_out&quot; : false,
  &quot;_shards&quot; : {
    &quot;total&quot; : 1,
    &quot;successful&quot; : 1,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  },
  &quot;hits&quot; : {
    &quot;total&quot; : {
      &quot;value&quot; : 7,
      &quot;relation&quot; : &quot;eq&quot;
    },
    &quot;max_score&quot; : 7.0,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;1&quot;,
        &quot;_score&quot; : 7.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Apple&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;exact_match&quot;,
          &quot;Partial first word match - end&quot;,
          &quot;Partial first word match - start&quot;,
          &quot;Exact first word match&quot;,
          &quot;fuzzy_1&quot;
        ]
      },
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;2&quot;,
        &quot;_score&quot; : 6.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Apple Computers&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Partial first word match - end&quot;,
          &quot;Partial first word match - start&quot;,
          &quot;Exact first word match&quot;
        ]
      },
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;3&quot;,
        &quot;_score&quot; : 5.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Big Apple Company&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Exact not first word match&quot;,
          &quot;Partial not first word match - end&quot;
        ]
      },
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;4&quot;,
        &quot;_score&quot; : 4.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Applesauce Company&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Partial first word match - start&quot;
        ]
      },
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;5&quot;,
        &quot;_score&quot; : 3.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Pineapple Manufacturing&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Partial first word match - end&quot;
        ]
      },
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;6&quot;,
        &quot;_score&quot; : 2.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Canadian Bakeapple&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;Partial not first word match - end&quot;
        ]
      },
      {
        &quot;_index&quot; : &quot;organizations&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;7&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;Apply&quot;
        },
        &quot;matched_queries&quot; : [
          &quot;fuzzy_1&quot;
        ]
      }
    ]
  }
}
</code></pre><p>Nice, from the most similar &ldquo;Exact match&rdquo; all the way down to the &ldquo;fuzzy&rdquo; matches.</p><p>I believe this post got a bit too long to continue working out the remaining requirements.
I&rsquo;ll finish the developments in the future post.
Also, it shouldn&rsquo;t be too hard to load bigger dataset to test our entity resolution algorithm, something like <a href=http://download.companieshouse.gov.uk/en_output.html>Companies House registry</a> with some real world data.</p><h2 id=summary>Summary</h2><p>I hope this exercise was interesting.
To sum up:</p><ul><li>I&rsquo;ve demonstrated how to do the text analysis tricks that would shape the organization name string according to the requirements.</li><li>As a way to normalize search scores I&rsquo;ve used the <code>constant_score</code> query. To come up with this trick is not very obvious because Elasticsearch scoring by default is unbounded due to text statistics and therefore not very well suited
to satisfy the requirements of matching semi structured short strings such ar organization names.</li><li>Another neat trick was to use the <code>dis_max</code> query to calculate the score by taking only the most significant similarity signal.
In this way we&rsquo;ve prevented the situations where less similar matches would go up because they matched several less significant
similarity rules and their score were added up.</li><li>Also, by using <code>_name</code> parameters for each query clause we get which similarity rules matched despite the fact that we&rsquo;ve took the score
of the highest scoring similarity rule. These flags might be used for further rescoring in your application.</li></ul><p>In case of any comments or questions don&rsquo;t hesitate to leave comments under this Github <a href=https://github.com/dainiusjocas/blog/issues/25>issue</a>.</p><h2 id=footnotes>Footnotes</h2><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Another approach would be to use hits <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/highlighting.html>highlighting</a>. <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Of course, this is a bit unrealistic because organization name might very well contain more than one word.
A hint on how to implement the same requrements for two word organization names would be to use <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-shingle-tokenfilter.html>shingles</a>. <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><div class=article-tags><a class="badge badge-light" href=/blog/tags/elasticsearch/>elasticsearch</a>
<a class="badge badge-light" href=/blog/tags/opensearch/>opensearch</a></div><div class=share-box aria-hidden=true><ul class=share><li><a href="https://twitter.com/intent/tweet?url=https://www.jocas.lt/blog/post/entity-resolution/&text=Entity%20Resolution%20with%20Opensearch/Elasticsearch" target=_blank rel=noopener class=share-btn-twitter><i class="fab fa-twitter"></i></a></li><li><a href="https://www.facebook.com/sharer.php?u=https://www.jocas.lt/blog/post/entity-resolution/&t=Entity%20Resolution%20with%20Opensearch/Elasticsearch" target=_blank rel=noopener class=share-btn-facebook><i class="fab fa-facebook-f"></i></a></li><li><a href="mailto:?subject=Entity%20Resolution%20with%20Opensearch/Elasticsearch&body=https://www.jocas.lt/blog/post/entity-resolution/" target=_blank rel=noopener class=share-btn-email><i class="fas fa-envelope"></i></a></li><li><a href="https://www.linkedin.com/shareArticle?url=https://www.jocas.lt/blog/post/entity-resolution/&title=Entity%20Resolution%20with%20Opensearch/Elasticsearch" target=_blank rel=noopener class=share-btn-linkedin><i class="fab fa-linkedin-in"></i></a></li><li><a href="https://web.whatsapp.com/send?text=Entity%20Resolution%20with%20Opensearch/Elasticsearch%20https://www.jocas.lt/blog/post/entity-resolution/" target=_blank rel=noopener class=share-btn-whatsapp><i class="fab fa-whatsapp"></i></a></li></ul></div><script src=https://giscus.app/client.js data-repo=dainiusjocas/blog data-repo-id="MDEwOlJlcG9zaXRvcnkyMjA4MjEwNzY=" data-category=General data-category-id=DIC_kwDODSl2VM4CPWBS data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script><div class="article-widget content-widget-hr"><h3>Related</h3><ul><li><a href=/blog/post/kibana-profile-many-shards-hack/>Make Elasticsearch Query Profiling Faster in Kibana</a></li><li><a href=/blog/talk/elasticsearch-community-meetup/>Lessons Learned While Scaling Elasticsearch @ Vinted</a></li><li><a href=/blog/talk/wearedevelopers-2021-05-12/>Don't Change the Partition Count for Kafka Topics!</a></li><li><a href=/blog/talk/vilnius-cloud-native-2021-04-07/>Don't Change the Partition Count for Kafka Topics!</a></li><li><a href=/blog/post/on-search-templates/>Using Search Templates in Elasticsearch</a></li></ul></div></div></article><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js integrity="sha256-1zu+3BnLYV9LdiY85uXMzii3bdrkelyp37e0ZyTAQh0=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/clojure.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js integrity="sha256-EErZamuLefUnbMBQbsEqu1USa+btR2oIlCpBJbyD4/g=" crossorigin=anonymous></script><script>hljs.initHighlightingOnLoad();</script><script>const search_config={"indexURI":"/blog/index.json","minLength":1,"threshold":0.3};const i18n={"no_results":"No results found","placeholder":"Search...","results":"results found"};const content_type={'post':"Posts",'project':"Projects",'publication':"Publications",'talk':"Talks"};</script><script id=search-hit-fuse-template type=text/x-template>
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script><script src=https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin=anonymous></script><script src=/blog/js/academic.min.d6bd04fdad2ad213aa8111c5a3b72fc5.js></script><div class=container><footer class=site-footer><p class=powered-by> 2022 Dainius Jocas &#183;
Powered by the
<a href=https://sourcethemes.com/academic/ target=_blank rel=noopener>Academic theme</a> for
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a>.
<span class=float-right aria-hidden=true><a href=# class=back-to-top><span class=button_icon><i class="fas fa-chevron-up fa-2x"></i></span></a></span></p></footer></div><div id=modal class="modal fade" role=dialog><div class=modal-dialog><div class=modal-content><div class=modal-header><h5 class=modal-title>Cite</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class=modal-body><pre><code class="tex hljs"></code></pre></div><div class=modal-footer><a class="btn btn-outline-primary my-1 js-copy-cite" href=# target=_blank><i class="fas fa-copy"></i>Copy</a>
<a class="btn btn-outline-primary my-1 js-download-cite" href=# target=_blank><i class="fas fa-download"></i>Download</a><div id=modal-error></div></div></div></div></div></body></html>